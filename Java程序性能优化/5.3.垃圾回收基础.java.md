# 5.3.垃圾回收基础
#### 5.3.1.垃圾回收作用
代替手工回收,减少出错
#### 5.3.2.垃圾回收算法与思想
* 1.引用计数法
> 当一个对象引用数量为0的时候表示,该对象不在被使用,这时候可以回收,同时也引入一个严重的问题,如果出现循环引用`A.next = A`的时候,会是的GC无法回收
* 2.标记-清除算法
    * 标记:通过根节点对对象进行标记,标记所有可达对象,未被标记的对象即未被引用的对象
    * 清除:清除所有没有被标记的对象
    * 缺点:回收之后空间不连续,对象在堆的分配过程中,尤其是大对象的内存分配,不连续的内存空间效率低于连续的内存空间
* 3.复制算法
    * 核心思想：将内存分为2块,每次只清除其中一块,在GC时,将正在使用的`A内存`中的存活对象复制到未使用的`B内存`中,之后清理正在使用的A内存中的所有对象,
交换2个角色,完成垃圾回收;<br>
    * 缺点：系统内存折半
> 在Java的`新生代串行垃圾回收器中,使用了复制算法的思想`,新生代分为eden/from/to三个区.假设此时from区正在被使用,则在执行GC时,
    * eden空间中的存活对象复制到to区
    * from空间中的存活对象被复制到to区/老年代; 如果to区满了,则将剩下的from区的存活对象复制到老年代
    * 清除eden/from区,切换from/to的角色
* 4.标记-压缩算法
标记-压缩算法是`老年代的回收算法`,执行过程：
    * 从根节点进行标记
    * 清理未标记的对象
    * 将所有存活对象压缩到内存的一端
    * 清理边界外的所有空间
* 5.增量算法
    * 原有GC算法缺陷:如果一次性将所有垃圾进行清理的画,会使APP处于Stop the World的状态,在STW的状态下APP的所有线程会挂起,暂停一切正常的工作,等待垃圾回收的完成.
    如果APP挂起很久会影响用户体验和系统的稳定性
    * 基本思想:垃圾回收线程和APP应用线程交替执行,每次指挥手一小片区域,接着切换到APP。如此反复,直到垃圾回收完成。这么做减小了APP停顿的时间
    * 缺点:线程间的上下文切换，使得GC总体成本上升,系统吞吐量下降
* 6.分代
基本思想：将内存区按照对象特点分块,根据内存特点的不同使用不同的回收算法
    * 新生代/年轻代   ---  复制算法
    * 老年代         ---  标记-压缩算法
#### 5.3.3.垃圾收集器类型
    * 线程数    ---   串行/并行
    * 工作模式  ---   并发/独占
    * 碎片处理  ---   压缩/非压缩
    * 分代      ---  新生代/老年代
#### 5.3.4.GC策略指标    
    * 吞吐量   ---   APP运行时间/系统总时间 = (系统总时间 - 垃圾回收时间)/系统总时间
    * 
