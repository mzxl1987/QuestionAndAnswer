# 5.1.Java虚拟机内存模型
java虚拟机内存分布:
  * 程序计数器
  * 虚拟机栈
  * 本地方法栈
  * Java 堆
  * 方法区
#### 5.1.1.程序计数器
关于程序计数器的相关描述：
  * 是一块内存空间
  * 每个线程都有`独立的程序计数器`,用于记录下一条要运行的指令
  * 线程间计数器`相互独立`，互不影响
  * `线程私有`的内存空间
#### 5.1.2.Java虚拟机栈
简述：
  * `线程私有`内存空间
  * 保存方法的局部变量,部分结果,并参与方法的调用和返回
与虚拟机栈空间有关的异常:
  * StackOverFlowError, 当前栈深度 > 最大可用的栈深度
  * OutOfMemoryError, 没有足够的空间支持栈的拓展<br>
> Hot Spot虚拟机中, `-Xss`来设置栈的大小, 栈大小决定了函数可调用的可达深度  
> 栈帧:虚拟机栈运行时使用的数据结构,用于保存上下文数据,栈帧的构成
  * 局部变量表
  * 操作数栈
  * 动态链接方法
  * 返回地址
> 栈帧中，与性能调优关心最为密切的是局部变量表,用于存放方法的参数和方法的内部参数,以`word`为单位,1word = 2bytes  
#### 5.1.3.本地方法栈
本地方法栈用于管理本地方法的调用,native方法是用C实现的，而不是Java<br>
在Hot Spot虚拟中,不区分`本地方法栈`和`虚拟机栈`,所以本地方法栈也会抛出StackOverFlowError和OutOfMemoryError
#### 5.1.4.Java堆
 * Heap是Java运行的时最为重要的部分,几乎所有的对象和数组都在Heap中分配空间<br>
 * Heap又分为`新生代`和`老年代`
   * 新生代：用于存放刚产生的对象和年轻对象,新生代又分为:
     * eden, 伊甸园
     * survivor space0,或者s0, from space
     * survivor space1,或者s1, to space
   * 老年代: 如果对象没有被回收,生存的时间够长,老年对象会移入老年代
> 堆空间
>> * 新生代
>>> * Eden
>>> * s0
>>> * s1
>> * 老年代
#### 5.1.5.方法区
与堆空间相似,被JVM中的虽有线程共享,方法区主要保存的信息是`类的元数据`,存储内容包括
* 类的类信息信息/class.type
  * 类的完整名称
  * 父类的完整名称
  * 类型修饰符
  * 类型的直接接口类表
* 常量池/final.pool
  * 类方法
  * 域等信息的所引用的常量信息
* 域信息/scope.info
  * 域名称
  * 域类型/域修饰符
* 方法信息/function.info
  * 方法名称
  * 返回类型
  * 方法参数
  * 方法修饰符
  * 方法字节码
  * 操作数栈
  * 方法帧栈的局部变量区大小以及异常表
> Hot Spot中,`方法区`也被称为`永久区`,独立于Java堆的内存空间.对于永久区的GC,需要从`常量池/类元数据`分析回收
